# Порівняння алгоритмів видачі решти

У цьому проекті реалізовано два підходи до задачі видачі решти: Жадібний алгоритм та Динамічне програмування. Нижче наведено порівняння їх ефективності.

## 1. Часова складність (Time Complexity)

### Жадібний алгоритм
- **Складність:** $O(K)$, де $K$ — кількість номіналів монет.
- **Поведінка:** Час виконання є миттєвим і сталим. Він не залежить від суми, яку потрібно видати. Алгоритм просто виконує ділення для кожного номіналу.
- **Продуктивність:** Надзвичайно висока. Навіть для суми `10^9` алгоритм працює за частки секунди.

### Динамічне програмування
- **Складність:** $O(S \cdot K)$, де $S$ — сума решти.
- **Поведінка:** Час виконання прямо пропорційний сумі решти. Алгоритм змушений обчислити оптимальне рішення для всіх чисел від `0` до `S`.
- **Продуктивність:** Низька при великих сумах. Для суми `1,000,000` алгоритм виконає у мільйони разів більше операцій, ніж жадібний.

## 2. Просторова складність (Space Complexity)

- **Жадібний алгоритм:** $O(1)$. Використовує фіксовану кількість пам'яті незалежно від вхідних даних.
- **Динамічне програмування:** $O(S)$. Потребує створення масиву (таблиці) розміром `S + 1`. При дуже великих сумах це може призвести до переповнення оперативної пам'яті (Memory Overflow).

## 3. Висновки

| Характеристика | Жадібний алгоритм | Динамічне програмування |
|----------------|-------------------|-------------------------|
| **Швидкість** | Дуже швидко (миттєво) | Повільно (залежить від суми) |
| **Пам'ять** | Мінімальна | Велика (залежить від суми) |
| **Оптимальність**| Тільки для "канонічних" систем | Гарантує оптимум завжди |

### Коли використовувати:

1.  **Жадібний алгоритм** є найкращим вибором для **стандартних валютних систем** (гривні, долари, євро). У цих системах номінали підібрані так, що жадібний підхід завжди дає мінімальну кількість монет. Його слід використовувати в реальних касових апаратах через ефективність при будь-яких сумах.

2.  **Динамічне програмування** слід використовувати лише тоді, коли набір номіналів є **нестандартним** (наприклад, `[1, 3, 4]`), і жадібний алгоритм не може гарантувати мінімальну кількість монет. Однак, для великих сум цей метод потребує оптимізації пам'яті.
